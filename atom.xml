<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lqy&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-06T08:54:46.163Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Liu qianyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>发布自己的npm包，并同步到github</title>
    <link href="http://example.com/2023/03/06/npm/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E5%B9%B6%E5%B0%86%E5%AE%83%E5%90%8C%E6%AD%A5%E5%88%B0github,gitlab/"/>
    <id>http://example.com/2023/03/06/npm/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E5%B9%B6%E5%B0%86%E5%AE%83%E5%90%8C%E6%AD%A5%E5%88%B0github,gitlab/</id>
    <published>2023-03-06T07:46:10.524Z</published>
    <updated>2023-03-06T08:54:46.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在开发项目的过程中，我们需要用到<a href="https://github.com/minio/minio">minio</a>接口去实现前端与s3分布式存储服务器的直接交互，在vue2项目中一切正常，但后来我们决定进行项目版本升级，采用vue3+vite开发。但Minio的官方客户端使用时必须依赖node.js, <a href="https://github.com/vitejs/vite/discussions/3083">无法在vite项目中使用</a>。</p><p>在搜索解决方案时看到了<a href="https://www.npmjs.com/package/minio-js">minio-js</a>,它提供了一种解决思路，即在这个项目中把minio的使用打包为纯js,可以在浏览器中直接调用minio的客户端。经过测试，接口可用。但是它只提供上传文件接口，接口不够完善，不能完全解决我们项目的问题，因此我决定改写这个项目,提供一些通用接口,并发布自己的npm包，从而更好地实现项目需求。具体项目描述可参考：<a href="https://github.com/Liuqianyik/minio-vite-js">minio-vite-js</a></p><h2 id="发布步骤"><a href="#发布步骤" class="headerlink" title="发布步骤"></a>发布步骤</h2><h3 id="1-首先我们准备一个需要打包发布的项目"><a href="#1-首先我们准备一个需要打包发布的项目" class="headerlink" title="1. 首先我们准备一个需要打包发布的项目"></a>1. 首先我们准备一个需要打包发布的项目</h3><p>我的项目结构大致如下：</p><p><img src="/imgs/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E5%B9%B6%E5%B0%86%E5%AE%83%E5%90%8C%E6%AD%A5%E5%88%B0github,gitlab/image-20230306165431543-16780928777802.png" alt="image-20230306165431543"></p><h4 id="1-1-初始化git"><a href="#1-1-初始化git" class="headerlink" title="1.1 初始化git"></a>1.1 初始化git</h4><p><code>git init</code></p><h4 id="1-2-修改package-json文件"><a href="#1-2-修改package-json文件" class="headerlink" title="1.2 修改package.json文件"></a>1.2 修改package.json文件</h4><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"minio-vite-js"</span>, <span class="comment">// npm包名称，不能与仓库中已有包重名</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.7"</span>, <span class="comment">// 版本号，每次更新之前要改这个版本号</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"minioclient with vite"</span>, <span class="comment">// npm包描述</span></span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/minio-js.js"</span>, <span class="comment">// 入口文件路径，在你通过import或require引用该npm包时就是引入的该路径的文件</span></span><br><span class="line">  <span class="attr">"scripts"</span>: {</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"minio"</span>, <span class="string">"vite"</span>, <span class="string">"vue3"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"liuqianyik"</span>, </span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: {</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^5.75.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^5.0.1"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"dependencies"</span>: {</span><br><span class="line">    <span class="attr">"minio"</span>: <span class="string">"^7.0.32"</span>,</span><br><span class="line">    <span class="attr">"node-polyfill-webpack-plugin"</span>: <span class="string">"^2.0.1"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="1-3-编写可读性强的说明文档README-md"><a href="#1-3-编写可读性强的说明文档README-md" class="headerlink" title="1.3 编写可读性强的说明文档README.md"></a>1.3 编写可读性强的说明文档README.md</h4><p>讲清楚项目应用的问题场景，使用方法，具体接口等</p><h4 id="1-4-构建项目"><a href="#1-4-构建项目" class="headerlink" title="1.4 构建项目"></a>1.4 构建项目</h4><p><code>npm run build</code></p><h3 id="2-发布npm包"><a href="#2-发布npm包" class="headerlink" title="2. 发布npm包"></a>2. 发布npm包</h3><h4 id="2-1-npm注册登录"><a href="#2-1-npm注册登录" class="headerlink" title="2.1 npm注册登录"></a>2.1 npm注册登录</h4><ul><li><p>先去npm官网注册账号：<a href="https://www.npmjs.com/%EF%BC%8C%E6%88%96%E8%80%85%E9%80%9A%E8%BF%87%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%86%8C%EF%BC%9A%60npm">https://www.npmjs.com/，或者通过终端命令注册：`npm</a> adduser`</p></li><li><p>终端登录npm账号：<code>npm login</code></p></li></ul><h4 id="2-2-发布"><a href="#2-2-发布" class="headerlink" title="2.2 发布"></a>2.2 发布</h4><ul><li>因为很多人把npm源都切到了淘宝源，毕竟速度快，但是发布npm前需要先恢复到npm官方源上，否则发布失败，切换命令(如果已经是官方源可忽略)：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 配置npm全局使用淘宝镜像源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">// 配置npm全局恢复官方镜像源</span><br><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></tbody></table></figure><ul><li>在npm包项目根目录运行命令：</li></ul><p><code>npm publish</code></p><p>运行完后，稍等片刻，在npm官网就可以搜索到发布的该npm包了。</p><h4 id="2-3-更新发布"><a href="#2-3-更新发布" class="headerlink" title="2.3 更新发布"></a>2.3 更新发布</h4><p>当你的项目有修改或更新，想要再次提交修改时：</p><ul><li>在package.json中修改版本号 </li><li>重新构建项目</li><li>再一次发布<code>npm publish</code></li></ul><h3 id="3-与github项目相关联"><a href="#3-与github项目相关联" class="headerlink" title="3. 与github项目相关联"></a>3. 与github项目相关联</h3><h4 id="3-1-在github上创建该项目，并将代码推送上去"><a href="#3-1-在github上创建该项目，并将代码推送上去" class="headerlink" title="3.1 在github上创建该项目，并将代码推送上去"></a>3.1 在github上创建该项目，并将代码推送上去</h4><h4 id="3-2-获取到github仓库地址，与npm仓库相关联"><a href="#3-2-获取到github仓库地址，与npm仓库相关联" class="headerlink" title="3.2 获取到github仓库地址，与npm仓库相关联"></a>3.2 获取到github仓库地址，与npm仓库相关联</h4><p>在package.json中配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">"repository": {</span><br><span class="line">  "type": "git",</span><br><span class="line">  "url": "git://github.com/Liuqianyik/minio-vite-js.git" //github仓库地址，把https改为git即可</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;在开发项目的过程中，我们需要用到&lt;a href=&quot;https://github.com/minio/minio&quot;&gt;minio</summary>
      
    
    
    
    <category term="npm" scheme="http://example.com/categories/npm/"/>
    
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>git pull --rebase与git pull的区别</title>
    <link href="http://example.com/2023/03/06/Git/git%20pull%20--rebase%E4%B8%8Egit%20pull%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2023/03/06/Git/git%20pull%20--rebase%E4%B8%8Egit%20pull%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-03-06T06:48:48.616Z</published>
    <updated>2023-03-06T07:35:55.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>多人协作，向同一远程分支提交修改，在push代码时可能报错</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">To github.com:hello/demo.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:hello/demo.git'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></tbody></table></figure><p><strong>报错原因：</strong>远程分支有新的提交我们还没有同步到本地，因此无法推送。所以我们需要先<code>git pull</code>,再<code>git push origin master</code>.</p><p>这里在git pull时，我们就有两种选择,选择哪种取决于我们想要什么样的git提交树：</p><p><code>git push origin master </code> 或<code>git push --rebase origin master</code></p><h2 id="git-pull-–rebase与git-pull的本质区别"><a href="#git-pull-–rebase与git-pull的本质区别" class="headerlink" title="git pull –rebase与git pull的本质区别"></a>git pull –rebase与git pull的本质区别</h2><ol><li><code>git pull</code>是一个组合命令，它会分两步执行，首先拉取远端代码，然后更新本地仓库，指令执行上的区别在于：</li></ol><blockquote><p>git pull origin master =  git fetch + git merge Fetch_Head</p><p>git pull –rebase origin master =  git fetch + git rebase Fetch_Head</p></blockquote><ol start="2"><li>git merge和git rebase的区别</li></ol><p>merge 是合并的意思，rebase是复位基底的意思。</p><p>现在我们有这样的两个分支,test和master，提交如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     D---E <span class="built_in">test</span></span><br><span class="line">    /</span><br><span class="line">A---B---C---F master</span><br></pre></td></tr></tbody></table></figure><p>在master执行<code>git merge test</code>然后会得到如下结果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     D--------E</span><br><span class="line">    /          \</span><br><span class="line">A---B---C---F---G    <span class="built_in">test</span> , master</span><br></pre></td></tr></tbody></table></figure><p>在master执行<code>git rebase test</code>,然后得到如下结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A---C---D---E---C `---F` test , master</span><br></pre></td></tr></tbody></table></figure><p>可以看到merge操作会生成一个新的节点，之前提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的操作。</p><p>通过上面可以看到，想要更好的提交树，使用rebase操作会更好一点，这样可以线性的看到每一次提交，并且没有增加提交节点。<br>在操作中。merge操作遇到冲突时候，当前merge不能继续下去。手动修改冲突内容后，add 修改，commit 就可以了<br>而rebase操作的话，会中断rebase，同时会提示去解决冲突。解决冲突后，将修改add后执行git rebase -continue继续操作，或者git rebase -skip忽略冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;多人协作，向同一远程分支提交修改，在push代码时可能报错&lt;/p&gt;
&lt;figure class=&quot;highlight bas</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3+VueRouter4+Keycloak配置问题</title>
    <link href="http://example.com/2023/02/22/Vue3.0/Vue3+VueRouter4+Keycloak%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/02/22/Vue3.0/Vue3+VueRouter4+Keycloak%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</id>
    <published>2023-02-22T07:58:36.566Z</published>
    <updated>2023-03-06T06:30:58.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>main.ts中keycloak onReady()回调函数在router之后执行，导致router中无法获取正确的用户登录状态</p><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>例1：访问未登陆首页，点击登录，进入登陆界面，登录成功之后会继续访问未登陆首页，此时应该自动判断用户已登录的状态并展示个人中心组件。<br>例2：在主机列表页，点击登出，登出完成之后，按keycloak的逻辑会继续回到主机列表页，但在未登录状态无权访问，按道理应该在路由守卫进行判断，并导航进入403无权访问界面，从而进一步回到未登陆首页。</p><h2 id="配置代码"><a href="#配置代码" class="headerlink" title="配置代码"></a>配置代码</h2><ol><li>vue2中官方有示例<br>可以在keyclaok onready之后再创建vue实例<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> VueKeyCloak <span class="keyword">from</span> <span class="string">'@dsb-norge/vue-keycloak-js'</span></span><br><span class="line">Vue.use(VueKeyCloak, {</span><br><span class="line">  <span class="attr">init</span>: {</span><br><span class="line">    <span class="attr">onLoad</span>: <span class="string">'check-sso'</span>,</span><br><span class="line">    <span class="attr">checkLoginIframe</span>: <span class="literal">false</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">config</span>: {</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">window</span>.VUE_APP_AUTH_URL,</span><br><span class="line">    <span class="attr">realm</span>: <span class="built_in">window</span>.VUE_APP_AUTH_REALM,</span><br><span class="line">    <span class="attr">clientId</span>: <span class="built_in">window</span>.VUE_APP_AUTH_CLIENT_ID,</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">onReady</span>: <span class="function"><span class="params">kc</span> =&gt;</span> {</span><br><span class="line">    kc.loadUserInfo().success(<span class="function">(<span class="params">data</span>)=&gt;</span> {</span><br><span class="line">      data.id = data.sub</span><br><span class="line">      data.username = data.preferred_username</span><br><span class="line">      store.commit(<span class="string">'auth/SET_CURRENT_USER'</span>, data)</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">new</span> Vue({</span><br><span class="line">      router,</span><br><span class="line">      store,</span><br><span class="line">      i18n,</span><br><span class="line">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> {</span><br><span class="line">        store.commit(<span class="string">'initialiseStore'</span>)</span><br><span class="line">      },</span><br><span class="line">      <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">    }).$mount(<span class="string">'#app'</span>)</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>vue3<br>vue3中API发生了变化，不再是创建实例这个概念了<br>参考</li></ol><ul><li><a href="https://www.psimms.de/keycloak-integration-in-vuejs-3/">Keycloak Integration in Vuejs 3</a></li><li><a href="https://github.com/dsb-norge/vue-keycloak-js">dsb-norge/vue-keycloak-js</a></li><li><a href="https://github.com/dsb-norge/vue-keycloak-js/issues/152">$keycloak with vue 3 and vue-router 4</a><strong>解决方案</strong><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createApp } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueKeycloak <span class="keyword">from</span> <span class="string">'@dsb-norge/vue-keycloak-js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> { VueKeycloakInstance } <span class="keyword">from</span> <span class="string">'@dsb-norge/vue-keycloak-js/dist/types'</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> { KeycloakInstance } <span class="keyword">from</span> <span class="string">"keycloak-js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用keycloak插件</span></span><br><span class="line">app.use(VueKeycloak, {</span><br><span class="line">  <span class="attr">init</span>: {</span><br><span class="line">    <span class="attr">onLoad</span>: <span class="string">'check-sso'</span>,</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">config</span>: {</span><br><span class="line">    <span class="attr">url</span>: <span class="keyword">import</span>.meta.env.VITE_APP_AUTH_URL,</span><br><span class="line">    <span class="attr">clientId</span>: <span class="keyword">import</span>.meta.env.VITE_APP_AUTH_CLIENT_ID,</span><br><span class="line">    <span class="attr">realm</span>: <span class="keyword">import</span>.meta.env.VITE_APP_AUTH_REALM,</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">onReady</span>: <span class="function">(<span class="params">keycloak: KeycloakInstance</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Keycloak ready'</span>, keycloak)</span><br><span class="line">    <span class="keyword">const</span> currentUser = currentUserStore()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(keycloak.authenticated) {</span><br><span class="line">      <span class="comment">// 对keycloak中的用户信息做处理，存储到store之类的</span></span><br><span class="line">      ...</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 等keycloak onready之后再引入router并挂载app对象</span></span><br><span class="line">    app.use(router, app)</span><br><span class="line">    app.mount(<span class="string">'#app'</span>)</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把keycloak发布为一个全局变量，可以在各个组件中使用$keycloak直接调用</span></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">'@vue/runtime-core'</span> {</span><br><span class="line">  <span class="keyword">interface</span> ComponentCustomProperties  {</span><br><span class="line">    <span class="attr">$keycloak</span>: VueKeycloakInstance</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;main.ts中keycloak onReady()回调函数在router之后执行，导致router中无法获取正确的用户登录</summary>
      
    
    
    
    <category term="Vue3.0" scheme="http://example.com/categories/Vue3-0/"/>
    
    
  </entry>
  
  <entry>
    <title>js动态拼接url</title>
    <link href="http://example.com/2023/02/16/JavaScript/js%20%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5url/"/>
    <id>http://example.com/2023/02/16/JavaScript/js%20%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5url/</id>
    <published>2023-02-16T02:50:08.582Z</published>
    <updated>2023-03-06T06:31:22.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>发起http请求的时候，中台API定义的route中会有需要我们自定义的参数，比如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/users?page=${page}&amp;size=${size}&amp;q=${q}</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">/users/:uid/collection</span><br></pre></td></tr></tbody></table></figure><h2 id="请求的url写法"><a href="#请求的url写法" class="headerlink" title="请求的url写法"></a>请求的url写法</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一（我之前用的，很不灵活，直接用加号连接字符串，不推荐）</span></span><br><span class="line">url = <span class="string">'/users?page='</span> + <span class="built_in">this</span>.page + <span class="string">'&amp;q='</span> + <span class="built_in">this</span>.q</span><br><span class="line">url = <span class="string">'/users/'</span> + <span class="built_in">this</span>.uid + <span class="string">'/collection'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二（推荐）</span></span><br><span class="line">url = <span class="string">`/users?page=<span class="subst">${<span class="built_in">this</span>.page}</span>&amp;q=<span class="subst">${<span class="built_in">this</span>.q}</span>`</span></span><br><span class="line">url = <span class="string">`/users/<span class="subst">${<span class="built_in">this</span>.uid}</span>/collection`</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;发起http请求的时候，中台API定义的route中会有需要我们自定义的参数，比如：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3+Vite构建项目</title>
    <link href="http://example.com/2023/02/15/Vue3.0/vue3+vite/"/>
    <id>http://example.com/2023/02/15/Vue3.0/vue3+vite/</id>
    <published>2023-02-15T12:47:26.144Z</published>
    <updated>2023-03-06T06:30:52.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Vue是什么？"><a href="#1-Vue是什么？" class="headerlink" title="1 Vue是什么？"></a>1 Vue是什么？</h2><p>Vue 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。</p><p>参考：<br>Vue官网：<a href="https://cn.vuejs.org/guide/introduction.html#what-is-vue">简介 | Vue.js</a></p><h3 id="1-1-Vue-特点"><a href="#1-1-Vue-特点" class="headerlink" title="1.1 Vue 特点"></a>1.1 Vue 特点</h3><p>Declarative Rendering，声明式渲染，基于JavaScript状态输出期望的HTML<br>Reactivity，反应式，自动追踪JavaScript状态，如有更新自动更新DOM</p><h3 id="1-2-Vue2-x-Vue3-0"><a href="#1-2-Vue2-x-Vue3-0" class="headerlink" title="1.2 Vue2.x - Vue3.0"></a>1.2 Vue2.x - Vue3.0</h3><p>2020年9月18日，Vue.js发布3.0版本</p><h4 id="1-2-1-新特性"><a href="#1-2-1-新特性" class="headerlink" title="1.2.1 新特性"></a>1.2.1 新特性</h4><ul><li>Vue3设计了一套强大的组合式API（Composition-API）代替了Vue2中的Option-API，提高了复用性，我们可以更加优雅的组织我们的代码，函数，让相关功能的代码更加有序的组织在一起</li><li>Vue3中使用Proxy配合Reflect从而代替了Vue2中的Object.defineProperty()方法，实现数据的响应式（数据代理）</li><li>组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中,减少标签层级, 减小内存占用</li><li>增加了一些新的组件标签，例如<teleport> <suspense></suspense></teleport></li><li>提供了一种新的脚手架工具 Vite</li></ul><h2 id="2-工程构建"><a href="#2-工程构建" class="headerlink" title="2 工程构建"></a>2 工程构建</h2><h3 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1 开发环境"></a>2.1 开发环境</h3><p>Sublime Text 4配置LSP支持TypeScript</p><ol><li>Install LSP, Vue Syntax Highlight and LSP-volar from Package Control.</li><li>重启 Sublime Text</li><li><a href="https://github.com/sublimelsp/LSP-volar">https://github.com/sublimelsp/LSP-volar</a></li></ol><p>配置LSP-volar：</p><ol><li>Ctrl+Shift+P 输入 LSP-volar Settings，打开配置界面</li><li>右侧面板（自定义参数）中增加配置，实现LSP-volar插件对js/ts文件语法提示<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"selector"</span>: <span class="string">"text.html.vue | source.ts | source.tsx | source.js | source.jsx"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>参考：<br><a href="https://cn.vuejs.org/guide/scaling-up/tooling.html">Vue工具链</a></p><h3 id="2-2-使用vite构建"><a href="#2-2-使用vite构建" class="headerlink" title="2.2 使用vite构建"></a>2.2 使用vite构建</h3><p>参考：</p><ul><li><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">创建一个项目| Vue CLI</a></li><li><a href="https://cn.vitejs.dev/">ViteJS</a></li><li><a href="https://github.com/vuejs/create-vue">Create Vue</a></li><li><a href="https://vuejs.org/guide/quick-start.html">Vue 3 Quick Start</a></li><li><a href="https://lxchuan12.gitee.io/create-vue/">Vue 团队公开快如闪电的全新脚手架工具 create-vue</a></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建项目</span><br><span class="line">npm init vue@3</span><br><span class="line">// 默认使用vite构建，选择TypeScript、Vue Router、Pinia、ESLint、Prettier</span><br><span class="line"></span><br><span class="line">// 2. 安装依赖</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">// 3. 部署开发测试服务器</span><br><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure><h4 id="2-2-1-配置-eslint-prettier"><a href="#2-2-1-配置-eslint-prettier" class="headerlink" title="2.2.1 配置 eslint-prettier"></a>2.2.1 配置 eslint-prettier</h4><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.json</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"htmlWhitespaceSensitivity"</span>: <span class="string">"ignore"</span>,</span><br><span class="line">  <span class="attr">"endOfLine"</span>: <span class="string">"auto"</span>,</span><br><span class="line">  <span class="attr">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"useTabs"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"tabWidth"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"bracketSpacing"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"bracketSameLine"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"singleAttributePerLine"</span>: <span class="literal">false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考：</p><ul><li><a href="https://prettier.io/docs/en/options.html">Prettier Options</a></li><li><a href="https://juejin.cn/post/7050127881371910152">ESlint与Prettier配置指南</a></li><li><a href="https://blog.csdn.net/qq_36800701/article/details/112545940">解决格式化插件Prettier，格式化操作后，结束标签＞跑到下一行的问题。</a></li></ul><h4 id="2-2-2-tsconfig-json"><a href="#2-2-2-tsconfig-json" class="headerlink" title="2.2.2 tsconfig.json"></a>2.2.2 tsconfig.json</h4><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compilerOptions → <span class="string">"noImplicitAny"</span>: <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Vue是什么？&quot;&gt;&lt;a href=&quot;#1-Vue是什么？&quot; class=&quot;headerlink&quot; title=&quot;1 Vue是什么？&quot;&gt;&lt;/a&gt;1 Vue是什么？&lt;/h2&gt;&lt;p&gt;Vue 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、</summary>
      
    
    
    
    <category term="Vue3.0" scheme="http://example.com/categories/Vue3-0/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue子组件调用父组件中的自定义方法</title>
    <link href="http://example.com/2022/08/13/Vue%E7%94%9F%E6%80%81/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/08/13/Vue%E7%94%9F%E6%80%81/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/</id>
    <published>2022-08-13T09:33:41.798Z</published>
    <updated>2023-03-06T06:34:05.470Z</updated>
    
    <content type="html"><![CDATA[<p>在vue项目中，父子组件之间传参和互相调用方法是经常需要用到的，这里主要讨论子组件通过调用父组件的方法,主要有以下三种方式</p><h2 id="一、通过this-parent调用父组件的方法"><a href="#一、通过this-parent调用父组件的方法" class="headerlink" title="一、通过this.$parent调用父组件的方法"></a>一、通过this.$parent调用父组件的方法</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/dam/child'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: { child },</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">};</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$parent.fatherMethod();</span></span><br><span class="line"><span class="javascript">            }</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    };</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但这种方法有弊端：<br>this.$parent指向的时子组件外第一层元素，当子组件在父组件中不是第一层嵌套关系时，就无法获取到负组件中的方法和数据<br>如以下情况就无法成功调用</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child2</span>&gt;</span><span class="tag">&lt;/<span class="name">child2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/dam/child'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: { child },</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">};</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当我们无法用this.$parent访问父组件的时候可以用$emit事件来实现子父组件通信。</p><h2 id="二、子组件里用-emit向父组件触发一个事件，父组件监听这个事件"><a href="#二、子组件里用-emit向父组件触发一个事件，父组件监听这个事件" class="headerlink" title="二、子组件里用$emit向父组件触发一个事件，父组件监听这个事件"></a>二、子组件里用$emit向父组件触发一个事件，父组件监听这个事件</h2><p>这种方式比较普遍，使用较多</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">usefather</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/dam/child'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">      child</span></span><br><span class="line"><span class="javascript">    },</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  };</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 触发父组件中由&lt;child @usefather="fatherMethod"&gt;定义调用的fatherMethod方法</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">'usefather'</span>); </span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  };</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="三、父组件中定义自定义属性，将该方法传递到子组件中，子组件中通过props接收，再进行调用，这里也可以进行传值"><a href="#三、父组件中定义自定义属性，将该方法传递到子组件中，子组件中通过props接收，再进行调用，这里也可以进行传值" class="headerlink" title="三、父组件中定义自定义属性，将该方法传递到子组件中，子组件中通过props接收，再进行调用，这里也可以进行传值"></a>三、父组件中定义自定义属性，将该方法传递到子组件中，子组件中通过props接收，再进行调用，这里也可以进行传值</h2><p>类似于父组件向子组件中传值，这种传递方法的方式将负组件中的方法传递给子组件，供子组件进行调用</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'~/components/dam/child'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: {</span></span><br><span class="line"><span class="javascript">      child</span></span><br><span class="line"><span class="javascript">    },</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'测试'</span>);</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  };</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childMethod()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: {</span></span><br><span class="line"><span class="javascript">      <span class="attr">fatherMethod</span>: {</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">default</span>: <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    },</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: {</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">this</span>.fatherMethod) {</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.fatherMethod();</span></span><br><span class="line"><span class="javascript">        }</span></span><br><span class="line"><span class="javascript">      }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  };</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ol><li><p>第一种方法最简便，但有限制条件</p></li><li><p>第二种方法使用的最多，数据流向比较清晰，和非父子组件传值的this.$observer.$emit()&nbsp; this.$observer.$on()使用方式类似（this.$emit()可以传多个值，this.$observer.$emit()只能传一个值）</p></li><li><p>第三种方法定义自定义属性，这种一般用来传递属性的，不用来传方法（自定义事件一般用来传函数，自定义属性一般用来传属性）</p></li></ol><h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul><li><a href="https://blog.51cto.com/u_15301829/3070906">vue子组件调用父组件的方法</a></li><li><a href="https://blog.csdn.net/aSmallProgrammer/article/details/103712589">Vue 子组件中 this.$parent 无法调用父组件的自定义方法</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在vue项目中，父子组件之间传参和互相调用方法是经常需要用到的，这里主要讨论子组件通过调用父组件的方法,主要有以下三种方式&lt;/p&gt;
&lt;h2 id=&quot;一、通过this-parent调用父组件的方法&quot;&gt;&lt;a href=&quot;#一、通过this-parent调用父组件的方法&quot; cla</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-moment时间格式化</title>
    <link href="http://example.com/2022/08/13/Vue%E6%8F%92%E4%BB%B6/vue-moment%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://example.com/2022/08/13/Vue%E6%8F%92%E4%BB%B6/vue-moment%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</id>
    <published>2022-08-13T08:17:36.442Z</published>
    <updated>2023-03-06T06:32:15.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、参考资料"><a href="#一、参考资料" class="headerlink" title="一、参考资料"></a>一、参考资料</h2><ol><li><a href="https://momentjs.com/">momentjs官网</a></li><li><a href="http://momentjs.cn/docs/">momentjs官网中文版使用文档</a></li><li><a href="https://github.com/brockpetrie/vue-moment?ref=madewithvuejs.com">github：vue-moment</a></li></ol><h2 id="二、vue安装插件及配置"><a href="#二、vue安装插件及配置" class="headerlink" title="二、vue安装插件及配置"></a>二、vue安装插件及配置</h2><h3 id="1-通过npm安装"><a href="#1-通过npm安装" class="headerlink" title="1. 通过npm安装"></a>1. 通过npm安装</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vue-moment</span><br></pre></td></tr></tbody></table></figure><h3 id="2-在项目中引入并配置插件"><a href="#2-在项目中引入并配置插件" class="headerlink" title="2. 在项目中引入并配置插件"></a>2. 在项目中引入并配置插件</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js全局引入</span></span><br><span class="line"><span class="keyword">import</span> VueMoment <span class="keyword">from</span> <span class="string">'vue-moment'</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置本地时区</span></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>)</span><br><span class="line">Vue.use(VueMoment, {</span><br><span class="line">  moment</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>一般后端传来的时间以及我们直接用<code>new Date()。getTime()</code>获取到的都是类似<code>1656673259949</code>的的字符串，在前端页面上展示的时间想要符合预期格式就需要用到momentjs插件</p><h4 id="3-1-常见用法："><a href="#3-1-常见用法：" class="headerlink" title="3.1. 常见用法："></a>3.1. 常见用法：</h4><ol><li>星期，年月日时分秒 <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ someDate | moment("YYYY") }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- e.g. "2010" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ someDate | moment("dddd, hA") }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- e.g. "Sun, 3PM" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ someDate | moment("dddd, MMMM Do YYYY, h:mm:ss a") }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- e.g. "Sunday, February 14th 2010, 3:25:50 pm" --&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li>计算时间差 <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 计算somedate到当前时间的间隔，输出eg:一个月前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ someDate | moment("from", "now") }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不加“now”，效果一样，以下是上面一行的简写版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ someDate | moment("from") }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给出参考时间的写法如下，计算 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>{{ someDate | moment("from", 1656673259949) }}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><a href="https://github.com/brockpetrie/vue-moment?ref=madewithvuejs.com">更多用法</a>在github官方项目可以看到</li><li><a href="https://momentjs.com/docs/#/displaying/from/">自定义格式的规则</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、参考资料&quot;&gt;&lt;a href=&quot;#一、参考资料&quot; class=&quot;headerlink&quot; title=&quot;一、参考资料&quot;&gt;&lt;/a&gt;一、参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://momentjs.com/&quot;&gt;momentjs官网&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="Vue插件" scheme="http://example.com/categories/Vue%E6%8F%92%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中watch对象内属性的方法</title>
    <link href="http://example.com/2022/08/13/Vue%E7%94%9F%E6%80%81/Vue%E4%B8%ADwatch%E5%AF%B9%E8%B1%A1%E5%86%85%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/08/13/Vue%E7%94%9F%E6%80%81/Vue%E4%B8%ADwatch%E5%AF%B9%E8%B1%A1%E5%86%85%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-08-13T07:47:39.563Z</published>
    <updated>2023-03-06T06:32:56.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题提出"><a href="#一、问题提出" class="headerlink" title="一、问题提出"></a>一、问题提出</h2><p>vue提供了watch方法，用于监听实例内data数据的变化。通常写法是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: {</span><br><span class="line">    count: 10，</span><br><span class="line">    blog:{</span><br><span class="line">        title:'my-blog',</span><br><span class="line">        categories:[]</span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line">watch: {</span><br><span class="line">    count: function (newval, oldVal) {</span><br><span class="line">        console.log(`new: %s, old: %s`, newVal, oldVal);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述情况里<code>data</code>中的<code>count</code>属性可以直接监听<br>但是如果需要监听的数据是对象内的某一属性值的变化:  </p><ul><li>直接watch整个对象的时候<code>(eg:blog)</code>会发现无论何时<code>newval</code>和<code>oldVal</code>的值都是一样的，这是因为<code>blog</code>这个对象的指向并没有发生改变。–&gt;深度监测</li><li>直接watch对象的属性<code>(eg:blog.categories)</code>就会报错。–&gt;用字符串来表示对象的属性调用或使用<code>computed</code>计算属性做中间层</li></ul><h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><h3 id="1-深度监测"><a href="#1-深度监测" class="headerlink" title="1.深度监测"></a>1.深度监测</h3><p>watch blog里面的deep设为了true，这样的话，如果修改了这个blog中的任何一个属性，都会执行handler这个方法。不过这样会造成更多的性能开销，尤其是对象里面属性过多，结构嵌套过深的时候。而且有时候我们就只想关心这个对象中的某个特定属性，这个时候可以这样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data: {</span><br><span class="line">    <span class="attr">blog</span>:{</span><br><span class="line">        <span class="attr">title</span>:<span class="string">'my-blog'</span>,</span><br><span class="line">        <span class="attr">categories</span>:[]</span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line"><span class="attr">watch</span>: {</span><br><span class="line">    <span class="attr">blog</span>:{</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newVal,oldVal</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`new: <span class="subst">${newVal}</span>, old: <span class="subst">${oldVal}</span>`</span>);</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-用字符串来表示对象的属性调用"><a href="#2-用字符串来表示对象的属性调用" class="headerlink" title="2.用字符串来表示对象的属性调用"></a>2.用字符串来表示对象的属性调用</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data: {</span><br><span class="line">    blog:{</span><br><span class="line">        title:'my-blog',</span><br><span class="line">        categories:[]</span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line">watch: {</span><br><span class="line">    'blog.categories'(newVal, oldVal) {</span><br><span class="line">        console.log(`new:${newVal}, old:${oldVal}`);</span><br><span class="line">    }, </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-使用computed计算属性做中间层"><a href="#3-使用computed计算属性做中间层" class="headerlink" title="3.使用computed计算属性做中间层"></a>3.使用computed计算属性做中间层</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data: {</span><br><span class="line">    <span class="attr">blog</span>:{</span><br><span class="line">        <span class="attr">title</span>:<span class="string">'my-blog'</span>,</span><br><span class="line">        <span class="attr">categories</span>:[]</span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line"><span class="attr">computed</span>: {</span><br><span class="line">    <span class="function"><span class="title">categories</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.blog.categories;</span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line"><span class="attr">watch</span>: {</span><br><span class="line">    <span class="function"><span class="title">categories</span>(<span class="params">newVal, oldVal</span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`new:<span class="subst">${newVal}</span>, old:<span class="subst">${oldVal}</span>`</span>);</span><br><span class="line">    }, </span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><ol><li><a href="https://v2.cn.vuejs.org/v2/guide/computed.html">计算属性和侦听器</a></li><li><a href="https://segmentfault.com/a/1190000018080301">Vue中watch对象内属性的方法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、问题提出&quot;&gt;&lt;a href=&quot;#一、问题提出&quot; class=&quot;headerlink&quot; title=&quot;一、问题提出&quot;&gt;&lt;/a&gt;一、问题提出&lt;/h2&gt;&lt;p&gt;vue提供了watch方法，用于监听实例内data数据的变化。通常写法是：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>css相对单位rem,em等和绝对单位px</title>
    <link href="http://example.com/2022/08/13/CSS/css%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8Drem,em%E7%AD%89%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%8D%95%E4%BD%8Dpx/"/>
    <id>http://example.com/2022/08/13/CSS/css%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8Drem,em%E7%AD%89%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%8D%95%E4%BD%8Dpx/</id>
    <published>2022-08-13T02:09:25.344Z</published>
    <updated>2023-03-06T06:33:13.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>传统的项目开发中，我们只会用到<code>px</code>、<code>%</code>、<code>em</code>这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性</p><p>从CSS3开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了<code>rem</code>、<code>vh</code>、<code>vw</code>、<code>vm</code>等一些新的计量单位</p><p>利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等</p><h2 id="二、长度单位分类"><a href="#二、长度单位分类" class="headerlink" title="二、长度单位分类"></a>二、长度单位分类</h2><p>总体来说css中的长度单位可以分为两种：相对长度单位和绝对长度单位</p><table><thead><tr><th>相对长度单位</th><th>em、ex、ch、rem、vw、vh、vmin、vmax、%</th></tr></thead><tbody><tr><td>绝对长度单位</td><td>cm、mm、in、px、pt、pc</td></tr></tbody></table><p>在这里主要介绍我们在开发中最常用到的px、em、rem、vh、vw</p><h2 id="三、详细介绍px、em、rem、vh、vw、"><a href="#三、详细介绍px、em、rem、vh、vw、" class="headerlink" title="三、详细介绍px、em、rem、vh、vw、%"></a>三、详细介绍px、em、rem、vh、vw、%</h2><h3 id="1-px"><a href="#1-px" class="headerlink" title="1. px"></a>1. px</h3><p>px，表示像素(pixel)，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中</p><p>有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的</p><p>这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关</p><h3 id="2-em"><a href="#2-em" class="headerlink" title="2. em"></a>2. em</h3><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）</p><p>特点：</p><ul><li>em 的值并不是固定的</li><li>em 会继承父级元素的字体大小</li><li>em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸.任意浏览器的默认字体高都是 16px<br>举个例子<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    我是系统字体16px</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:2em"</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">        我是相对父级元素[1]字体大小2倍，32px</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:2em"</span> <span class="attr">id</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">            我是相对父级元素[2]字体大小2倍，相对元素[1]字体大小4倍，64px</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3. rem"></a>3. rem</h3><p>rem，相对单位，相对的只是HTML根元素font-size的值</p><p>同理，如果想要简化font-size的转化，我们可以在根元素html中加入font-size: 62.5%</p><p>html {font-size: 62.5%;  } /*  公式16px*62.5%=10px  */<br>这样页面中1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助</p><p>特点：</p><ul><li><p>rem单位可谓集相对大小和绝对大小的优点于一身</p></li><li><p>和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸  </p></li></ul><p>举个例子</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    我是系统字体16px</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:2rem"</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">        我是相对根元素字体的2倍：32px</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size:2rem"</span> <span class="attr">id</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">            我也是相对根元素字体的2倍：32px</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-vw"><a href="#4-vw" class="headerlink" title="4. vw"></a>4. vw</h3><p>css3新单位，viewpoint width的缩写，视窗宽度，1vw等于视窗宽度的1%。</p><p>举个例子：浏览器宽度1200px, 1 vw = 1200px/100 = 12 px。</p><h3 id="5-vh"><a href="#5-vh" class="headerlink" title="5. vh"></a>5. vh</h3><p>css3新单位，viewpoint height的缩写，视窗高度，1vh等于视窗高度的1%。</p><p>举个例子：浏览器高度900px, 1 vh = 900px/100 = 9 px。</p><h3 id="6"><a href="#6" class="headerlink" title="6. %"></a>6. %</h3><p>一般宽泛的讲是相对于父元素，但是并不是十分准确。</p><p>1、对于普通定位元素就是我们理解的父元素</p><p>2、对于position: absolute;的元素是相对于已定位的父元素</p><p>3、对于position: fixed;的元素是相对于 ViewPort（可视窗口）</p><h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><ol><li>一般情况下我们会在代码根元素中设置<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>{</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">62.5%</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>使得根元素字体大小为10px，这样方便换算1.2rem=12px</li><li>谷歌浏览器强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px,子节点rem的计算还是以12px为基准</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;传统的项目开发中，我们只会用到&lt;code&gt;px&lt;/code&gt;、&lt;code&gt;%&lt;/code&gt;、&lt;code&gt;em&lt;/code&gt;这</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>防止按钮多次点击以及点击后不自动失焦问题</title>
    <link href="http://example.com/2022/08/13/JavaScript/%E9%98%B2%E6%AD%A2%E6%8C%89%E9%92%AE%E5%A4%9A%E6%AC%A1%E7%82%B9%E5%87%BB%E4%BB%A5%E5%8F%8A%E7%82%B9%E5%87%BB%E5%90%8E%E4%B8%8D%E8%87%AA%E5%8A%A8%E5%A4%B1%E7%84%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/08/13/JavaScript/%E9%98%B2%E6%AD%A2%E6%8C%89%E9%92%AE%E5%A4%9A%E6%AC%A1%E7%82%B9%E5%87%BB%E4%BB%A5%E5%8F%8A%E7%82%B9%E5%87%BB%E5%90%8E%E4%B8%8D%E8%87%AA%E5%8A%A8%E5%A4%B1%E7%84%A6%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-13T01:23:51.849Z</published>
    <updated>2023-03-06T06:37:35.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题需求"><a href="#问题需求" class="headerlink" title="问题需求"></a>问题需求</h2><ul><li>点击按钮，通过click事件发起网络请求</li><li>点击之后按钮进入disabled状态，防止在请求完成之前二次点击，二次发起相同请求</li><li>点击之后按钮中显示的内容变为【暂停中…】，提示用户正在进行请求，提升用户交互体验</li><li>请求完成之后，按钮自动失焦，恢复原有状态</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/05bbf9cf86de">elementui中el-button点击后不失去焦点(按钮颜色不变)的解决</a></li><li><a href="https://stackoverflow.com/questions/16715075/preventing-multiple-clicks-on-button">Preventing multiple clicks on button</a></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击该按钮，就会触发restart方法，向后端发起ajax请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"restart"</span> <span class="attr">id</span>=<span class="string">"restart"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"bx bx-revision me-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 重启</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>参考文章中给出的解决方案是直接用点击事件发生的元素解决问题，即</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">restart</span>(<span class="params">evt</span>)</span> {</span><br><span class="line">    <span class="keyword">let</span> target = evt.target;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName == <span class="string">"SPAN"</span>){</span><br><span class="line">        target = evt.target.parentNode;</span><br><span class="line">    }</span><br><span class="line">    target.blur();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里做了一步判断，也就是说，如果按钮中有多个子元素，点击按钮时点击到这些子元素所在的区域，我们就得一一做if判断，在去获取父级元素，也就是我们需要操作的button，这样比较麻烦<br>改进：直接用<code>document.getElementById</code>获取按钮元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">restart</span>(<span class="params"></span>)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据元素id获取button元素</span></span><br><span class="line">    <span class="keyword">let</span> evt = <span class="built_in">document</span>.getElementById(<span class="string">"restart"</span>)</span><br><span class="line">    <span class="comment">// 将button原始子元素暂存，用于请求结束后恢复</span></span><br><span class="line">    <span class="keyword">let</span> innerHTML = evt.innerHTML</span><br><span class="line">    <span class="comment">// 获取button元素的子元素，并将内容变为‘暂停中..’（我加了一个spin的加载动画），给用户交互提示</span></span><br><span class="line">    evt.innerHTML = <span class="string">'&lt;span class="spinner-border spinner-border-sm me-1" role="status"&gt;&lt;/span&gt;正在重启...'</span></span><br><span class="line">    <span class="comment">// 点击重启按钮之后将暂停按钮变为不可点击状态</span></span><br><span class="line">    evt.disabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起网络请求</span></span><br><span class="line">    <span class="built_in">this</span>.$axios.post(<span class="built_in">this</span>.GLOBAL.host+“后台接口地址”，<span class="built_in">this</span>.$qs.stringify(data))</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求完成</span></span><br><span class="line">            <span class="keyword">if</span>(data.code === <span class="number">1</span>) {</span><br><span class="line">                <span class="comment">// 通知用户请求结果</span></span><br><span class="line">                <span class="built_in">this</span>.$notify({ <span class="attr">text</span>: <span class="string">'重启成功!'</span>, <span class="attr">type</span>: <span class="string">'success'</span>, <span class="attr">group</span>: <span class="string">'app'</span> })            </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">this</span>.$notify({ <span class="attr">text</span>: <span class="string">'重启失败!'</span>, <span class="attr">type</span>: <span class="string">'error'</span>, <span class="attr">group</span>: <span class="string">'app'</span> })</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 重启完成之后将重启按钮的内容恢复为原来的内容，</span></span><br><span class="line">            evt.innerHTML = innerHTML</span><br><span class="line">            <span class="comment">// 取消disabled状态</span></span><br><span class="line">            evt.disabled = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 让按钮失焦</span></span><br><span class="line">            evt.blur();</span><br><span class="line">        })</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题需求&quot;&gt;&lt;a href=&quot;#问题需求&quot; class=&quot;headerlink&quot; title=&quot;问题需求&quot;&gt;&lt;/a&gt;问题需求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;点击按钮，通过click事件发起网络请求&lt;/li&gt;
&lt;li&gt;点击之后按钮进入disabled状态，防止在请求完成</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue Router</title>
    <link href="http://example.com/2022/07/30/Vue%E7%94%9F%E6%80%81/Vue%20Router/"/>
    <id>http://example.com/2022/07/30/Vue%E7%94%9F%E6%80%81/Vue%20Router/</id>
    <published>2022-07-30T01:55:23.060Z</published>
    <updated>2023-03-06T06:32:44.612Z</updated>
    
    <content type="html"><![CDATA[<p>通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ol><li>路由是指根据url的不同，展示不同的内容</li><li>router-link是跳转路由的标签，通过点击router-link标签，可以帮我们快速跳转到设置的路由下去</li><li>router-view负责展示当前路由对应的组件内容</li><li>/route/index.js文件下定义不同路由和其对应组件之间的关系<h3 id="最简实例"><a href="#最简实例" class="headerlink" title="最简实例"></a>最简实例</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 router-link 组件进行导航 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过传递 `to` 来指定路由/链接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Go to Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>Go to About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li>我们没有使用常规的 a 标签，而是使用一个自定义组件 router-link 来创建链接。这使得 <code>Vue Router</code> 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。</li><li><blockquote><p><code>router-view</code> 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。<br>可以理解为是一个占位符，你点击一个routerlink，对应routerview的地方就展示路由对应的组件界面</p></blockquote></li></ol><h3 id="项目中配置Router的步骤"><a href="#项目中配置Router的步骤" class="headerlink" title="项目中配置Router的步骤"></a>项目中配置Router的步骤</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义路由组件.</span></span><br><span class="line"><span class="comment">// 也可以从其他文件导入</span></span><br><span class="line"><span class="keyword">const</span> Home = { <span class="attr">template</span>: <span class="string">'&lt;div&gt;Home&lt;/div&gt;'</span> }</span><br><span class="line"><span class="keyword">const</span> About = { <span class="attr">template</span>: <span class="string">'&lt;div&gt;About&lt;/div&gt;'</span> }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一些路由</span></span><br><span class="line"><span class="comment">// 每个路由都需要映射到一个组件。</span></span><br><span class="line"><span class="comment">// 我们后面再讨论嵌套路由。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  { <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: Home },</span><br><span class="line">  { <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: About },</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由实例并传递 `routes` 配置</span></span><br><span class="line"><span class="comment">// 你可以在这里输入更多的配置，但我们在这里</span></span><br><span class="line"><span class="comment">// 暂时保持简单</span></span><br><span class="line"><span class="keyword">const</span> router = VueRouter.createRouter({</span><br><span class="line">  <span class="comment">// 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。</span></span><br><span class="line">  <span class="attr">history</span>: VueRouter.createWebHashHistory(),</span><br><span class="line">  routes, <span class="comment">// `routes: routes` 的缩写</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建并挂载根实例</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp({})</span><br><span class="line"><span class="comment">//确保 _use_ 路由实例使</span></span><br><span class="line"><span class="comment">//整个应用支持路由。</span></span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，应用已经启动了！</span></span><br></pre></td></tr></tbody></table></figure><p>  通过调用 app.use(router)，我们可以在任意组件中以 this.$router 的形式访问它，并且以 this.$route 的形式访问当前路由：</p><pre><code class="js">// Home.vueexport default {  computed: {    username() {      // 我们很快就会看到 `params` 是什么      return this.$route.params.username    },  },  methods: {    goToDashboard() {      if (isAuthenticated) {        this.$router.push('/dashboard')      } else {        this.$router.push('/login')      }    },  },}</code></pre><p>要在 setup 函数中访问路由，请调用 useRouter 或 useRoute 函数。</p><p>在整个文档中，我们会经常使用 router 实例，请记住，this.$router 与直接使用通过 createRouter 创建的 router 实例完全相同。我们使用 this.$router 的原因是，我们不想在每个需要操作路由的组件中都导入路由。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。&lt;/p&gt;
&lt;h3 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue项目目录中各文件的作用</title>
    <link href="http://example.com/2022/07/24/PsiAI%E9%A1%B9%E7%9B%AE/vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2022/07/24/PsiAI%E9%A1%B9%E7%9B%AE/vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2022-07-24T03:08:36.363Z</published>
    <updated>2023-03-06T06:42:45.278Z</updated>
    
    <content type="html"><![CDATA[<ol><li>node_modules: 用于存放我们项目的各种依赖，比如axios等，没有moudles文件，项目就没法运行，可以使用 npm install进行项目依赖的安装</li><li>public:用于存放静态文件</li><li>public/index.html:是一个模板文件，作用是生成项目的入口文件，webpack打包的js,css也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html</li><li>src:我们存放各种vue文件的地方</li><li>src/assets:用于存放各种静态文件，如图片等</li><li>src/compnents：用于存放我们的公共组件，如 header、footer等</li><li>src/views：用于存放我们写好的各种页面，如login、main等</li><li>src/APP.VUE: 主vue模块 引入其他模块，app.vue是项目的主组件，所有页面都是在app.vue下切换的</li><li>src/main.js: 入口文件，主要作用是初始化vue实例，同时可以在此文件中引用某些组件库或者全局挂在一些变量</li><li>src/router.js: 路由文件，这个里边可以理解为各个页面的地址路径，用于我们访问，同时可以直接在里边编写路由守卫</li><li>src/store.js：主要用于项目里边的一些状态的保存，state中保存状态，mutations中写用于修改state中的状态，actions暂时没实践，不知道具体怎么使用</li><li>package.json: 模块基本信息项目开发所需要模块，版本，项目名称</li><li>package-lock.json: 是在 npm install时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号</li><li>babel.config.js: 是一个工具链，主要用于在当前和较旧的浏览器或环境中将ECMAScript 2015+代码转换为JavaScript的向后兼容版本</li><li>gitignore: git上传需要忽略的文件格式</li><li>postcss.config.js: postcss 是帮我们后处理css ，css已经编译完成了，在stylus-loader编译成css之后，在通过postcss优化css，通过一系列组件去优化，比如以下，通过autoprefixer 添加css前缀<br>vue.config.js: 保存vue配置的文件，可以用于设置代理,打包配置等</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;node_modules: 用于存放我们项目的各种依赖，比如axios等，没有moudles文件，项目就没法运行，可以使用 npm install进行项目依赖的安装&lt;/li&gt;
&lt;li&gt;public:用于存放静态文件&lt;/li&gt;
&lt;li&gt;public/index.h</summary>
      
    
    
    
    <category term="PsiAI项目" scheme="http://example.com/categories/PsiAI%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>在本机运行dvclab项目步骤</title>
    <link href="http://example.com/2022/07/23/PsiAI%E9%A1%B9%E7%9B%AE/%E5%9C%A8%E6%9C%AC%E6%9C%BA%E8%BF%90%E8%A1%8Cdvclab%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2022/07/23/PsiAI%E9%A1%B9%E7%9B%AE/%E5%9C%A8%E6%9C%AC%E6%9C%BA%E8%BF%90%E8%A1%8Cdvclab%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-07-23T08:10:38.568Z</published>
    <updated>2023-03-06T06:43:05.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h2><p>参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">廖雪峰Git</a></p><h2 id="2-克隆项目到本地"><a href="#2-克隆项目到本地" class="headerlink" title="2. 克隆项目到本地"></a>2. 克隆项目到本地</h2><ul><li>在gitlab或者github找到想clone的项目地址，如<a href="https://gitlab.dvclab.com/frontend/DvcAI-fe.git">https://gitlab.dvclab.com/frontend/DvcAI-fe.git</a>  </li><li>到你想下载的目录下打开命令行 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.dvclab.com/frontend/DvcAI-fe.git</span><br></pre></td></tr></tbody></table></figure><h2 id="3-下载依赖包-一开始项目是用yarn构建的"><a href="#3-下载依赖包-一开始项目是用yarn构建的" class="headerlink" title="3. 下载依赖包: 一开始项目是用yarn构建的"></a>3. 下载依赖包: 一开始项目是用yarn构建的</h2> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></tbody></table></figure><h2 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4. 运行项目"></a>4. 运行项目</h2> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/8960</summary>
      
    
    
    
    <category term="PsiAI项目" scheme="http://example.com/categories/PsiAI%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>sublime使用方法记录</title>
    <link href="http://example.com/2022/07/18/sublime%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2022/07/18/sublime%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</id>
    <published>2022-07-18T03:53:53.544Z</published>
    <updated>2023-03-06T06:36:55.459Z</updated>
    
    <content type="html"><![CDATA[<p>  之前一直用的是vscode，现在因为导师要求和项目需要，改用sublime，记录一下从零到一的使用过程，留下一些使用技巧供自己以后回顾</p><h2 id="一、下载安装"><a href="#一、下载安装" class="headerlink" title="一、下载安装"></a>一、下载安装</h2><p>直接去官网<a href="https://www.sublimetext.com/download_thanks?target=win-x64">sublime</a>下载，是免费的</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><ol><li>设置主题<br>preferences ==&gt; select theme ==&gt; 选择自己想要的主题即可</li><li>安装package control<br>菜单栏tools ==&gt; Install Package Control…</li><li>安装插件  <ul><li>打开package control快捷键：<code>Shift + Ctrl + P</code></li><li>在搜索框中输入install，选择第一项“Package Control: Install Package”,点击之后等一会会出现package control的搜索框</li><li>接下来就可以搜索需要的插件名进行下载了</li><li><strong>注意：</strong> 每次下载插件都需要重复2，3步</li></ul></li><li>Sublime Text 3偏好设置  <ul><li>设置 tab 为2个空格  <ul><li>Preferences =&gt; Setting =&gt; 在文件中如下添加两行代码设置<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"tab_size"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">"translate_tabs_to_spaces"</span>: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>设置Sublime Text备注颜色  <ul><li>通过Package Control: Install Package安装PackageResourceViewer  </li><li>Ctrl+Shift+P 搜索选择 PackageResourceViewer: OpenResource  </li><li>继续搜索选择 Color Scheme - Default  (可以选择你想要的color scheme)</li><li>选择Monokai.sublime-color-scheme（monokai是我选择的color scheme，自己要用哪个colrscheme就改哪个）, rules中添加：<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Comment"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"comment"</span>,</span><br><span class="line">  <span class="attr">"foreground"</span>: <span class="string">"#888888"</span></span><br><span class="line">},</span><br><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Comment Line"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"comment.line"</span>,</span><br><span class="line">  <span class="attr">"foreground"</span>: <span class="string">"#00fa9f"</span></span><br><span class="line">},</span><br><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Comment Block"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"comment.block"</span>,</span><br><span class="line">  <span class="attr">"foreground"</span>: <span class="string">"#666666"</span></span><br><span class="line">},</span><br><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Comment Block Document"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"comment.block.documentation"</span>,</span><br><span class="line">  <span class="attr">"foreground"</span>: <span class="string">"#00fa9f"</span>,</span><br><span class="line">  <span class="attr">"background"</span>: <span class="string">"#3f3f3f"</span>,</span><br><span class="line">  <span class="attr">"font_style"</span>: <span class="string">"italic"</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol><h2 id="三、开发需要用到的插件"><a href="#三、开发需要用到的插件" class="headerlink" title="三、开发需要用到的插件"></a>三、开发需要用到的插件</h2><ol><li><a href="https://packagecontrol.io/packages/Vue%20Syntax%20Highlight">Vue Syntax Hightlight</a>：vue代码高亮</li><li><a href="https://packagecontrol.io/packages/SublimeLinter">Sublimelinter</a>：代码检查框架插件，支持各种语言的检查，但其本身并没有代码检查的功能</li><li><a href="https://packagecontrol.io/packages/SublimeLinter-eslint">SublimeLinter-eslint</a>：在SublimeLinter插件的基础上，需要添加该插件Sublime​Linter-eslint，实现对 ESLint 语言检查支持</li><li><a href="https://packagecontrol.io/packages/Sass">Sass</a>：实现Scss和Sass语法高亮</li><li><a href="">x</a>：高亮显示代码配色</li><li><a href="https://github.com/randy3k/Terminus">Terminus</a>：调出终端</li><li>终端快捷键配置：  <ul><li>选择SublimeText3 -&gt; Preference -&gt; Key Bindings打开快捷键配置文件</li><li>按如下方式配置快捷键配置文件：<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择ctrl+shift+T来进行Terminus终端的打开操作</span></span><br><span class="line">[</span><br><span class="line">   { <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+t"</span>], <span class="attr">"command"</span>: <span class="string">"toggle_terminus_panel"</span> }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></li><li><strong>注意：</strong> 自定义的快捷键可能和默认设置有重合，这时可能会不生效，在不生效的时候可以检查一下，如果真的有重合就换一个快捷键</li></ul></li><li><a href="https://www.php.cn/tool/sublime/457675.html">markdown相关</a>  <ul><li>Markdown Preview</li><li>Markdown Editing</li><li>设置Markdown编辑高亮，打开Perferences &gt; Package Settings &gt; Markdown Preview &gt; Setting-User,输入以下代码，保存<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="attr">"font_size"</span>: <span class="number">13</span>,    <span class="attr">"ignored_packages"</span>:</span><br><span class="line">  </span><br><span class="line">  [        <span class="string">"Vintage"</span></span><br><span class="line">  </span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">      Enable or not mathjax support.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  */</span>    <span class="attr">"enable_mathjax"</span>: <span class="literal">true</span>,</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">      Enable or not highlight.js support for syntax highlighting.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  */</span>    <span class="attr">"enable_highlight"</span>: <span class="literal">true</span>,</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>设置浏览器预览快捷键，打开Perferences &gt; Key Bindings，在右边输入以下代码，保存 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"keys": ["Ctrl+m"], "command": "markdown_preview", "args":{"target" : "browser"} }</span><br></pre></td></tr></tbody></table></figure></li><li>验证是否配置成功，新建后缀为.md的文档，用Sublime编辑，保存,然后按快捷键ctrl+m,在默认浏览器中显示预览结果</li></ul></li><li>SideBarEnhancements</li></ol><ul><li>SideBarEnhancements 是一款很实用的右键菜单增强插件，有以 diff形式显示未保存的修改、在文件管理器中显示该文件、复制文件路径、在侧边栏中定位该文件等功能，也有基础的诸如新建文件/目录，编辑，打开/运行，显示，在选择中/上级目录/项目中查找，剪切，复制，粘贴，重命名，删除，刷新等常见功能。</li></ul><h2 id="四、可能遇到的问题"><a href="#四、可能遇到的问题" class="headerlink" title="四、可能遇到的问题"></a>四、可能遇到的问题</h2><ol><li>packages contorl安装插件装不上<br>解决办法：<br>直接菜单栏Perferences    –&gt;Browse Packages，Package Control  拷贝到sublime 的packages目录下，重启后重新点击  菜单栏Perferences，可以正常安装插件。</li><li>全局搜索快捷键不生效<br>菜单栏find =&gt; find in files可以全局搜索，但快捷键<code>ctrl+shift+f</code>不生效</li></ol><ul><li>原因：输入法中的繁简切换快捷键冲突了</li><li>解决方法：在输入法的设置中把繁简切换快捷键取消掉</li></ul><h2 id="五、常用快捷键"><a href="#五、常用快捷键" class="headerlink" title="五、常用快捷键"></a>五、常用快捷键</h2><ul><li><code>ctrl+shift+~</code> 跳出终端</li><li><code>ait+shift+2</code>  分屏</li><li><code>ctrl+f</code> 在当前文件中查找</li><li>``</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  之前一直用的是vscode，现在因为导师要求和项目需要，改用sublime，记录一下从零到一的使用过程，留下一些使用技巧供自己以后回顾&lt;/p&gt;
&lt;h2 id=&quot;一、下载安装&quot;&gt;&lt;a href=&quot;#一、下载安装&quot; class=&quot;headerlink&quot; title=&quot;一、下</summary>
      
    
    
    
    <category term="软件使用" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="sublime" scheme="http://example.com/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>js,html,css注释方式</title>
    <link href="http://example.com/2022/07/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/js,html,css%E6%B3%A8%E9%87%8A%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/07/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/js,html,css%E6%B3%A8%E9%87%8A%E6%96%B9%E5%BC%8F/</id>
    <published>2022-07-13T10:43:28.050Z</published>
    <updated>2023-03-06T06:36:01.928Z</updated>
    
    <content type="html"><![CDATA[<p>为了是代码更规范，增加代码的可读性，我们在写代码的时候一定要注意注释的添加，那相应的注释格式也有所不同。</p><h2 id="一、js中的注释"><a href="#一、js中的注释" class="headerlink" title="一、js中的注释"></a>一、js中的注释</h2><p>分为三种：单行注释、多行注释、方法注释</p><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1. 单行注释"></a>1. 单行注释</h3><ul><li>最常见的”//“,在程序间随处可见,只能注释单行</li><li>比较重要，高亮颜色需要最醒目<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一行注释，只能注释单行。</span></span><br><span class="line"><span class="comment">// 另一行注释</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-多行注释multi-line-comment"><a href="#2-多行注释multi-line-comment" class="headerlink" title="2. 多行注释multi-line comment"></a>2. 多行注释multi-line comment</h3></li><li>多行注释以 /* 开始，以 */ 结尾</li><li>一般js文件开头，介绍作者，函数等信息</li><li>一般不太重要，高亮颜色设为不影响阅读代码的灰色即可<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">author:xxx</span></span><br><span class="line"><span class="comment">day:2008-08-10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-方法注释function-annotation"><a href="#3-方法注释function-annotation" class="headerlink" title="3. 方法注释function annotation"></a>3. 方法注释function annotation</h3></li><li>在方法之前定义，描述这个函数的功能，参数，编写者等信息</li><li>注释颜色醒目程度介于1，2之间<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name <span class="variable">hash</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>Random hashing algorithm I found on Stack Overflow.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">{string}</span> </span>str </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">{boolean}</span> </span>asString </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">{*}</span> </span>seed </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">{string}</span> <span class="variable">hash</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">str, asString, seed</span>) </span>{...}</span><br></pre></td></tr></tbody></table></figure><h2 id="二、html中的注释"><a href="#二、html中的注释" class="headerlink" title="二、html中的注释"></a>二、html中的注释</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个注释，注释在浏览器中不会显示 --&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="三、css中的注释"><a href="#三、css中的注释" class="headerlink" title="三、css中的注释"></a>三、css中的注释</h2></li><li>可以写在样式表中任意允许空格的位置。</li><li>可以写成一行，也可以写成多行。</li><li>/* */ 风格的注释语法可以用作单行注释，也可以用作多行注释<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面的注释用于禁用特定的样式 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">span {</span></span><br><span class="line"><span class="comment">  color: blue;</span></span><br><span class="line"><span class="comment">  font-size: 1.5em;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span> {</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="comment">/* font-size: 1.5em; */</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了是代码更规范，增加代码的可读性，我们在写代码的时候一定要注意注释的添加，那相应的注释格式也有所不同。&lt;/p&gt;
&lt;h2 id=&quot;一、js中的注释&quot;&gt;&lt;a href=&quot;#一、js中的注释&quot; class=&quot;headerlink&quot; title=&quot;一、js中的注释&quot;&gt;&lt;/a&gt;一、</summary>
      
    
    
    
    <category term="前端基础" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="注释" scheme="http://example.com/tags/%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>js回调函数用法</title>
    <link href="http://example.com/2022/07/11/JavaScript/js%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/07/11/JavaScript/js%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/</id>
    <published>2022-07-11T14:50:45.191Z</published>
    <updated>2023-03-06T06:36:18.529Z</updated>
    
    <content type="html"><![CDATA[<p>记录我在开发过程中总遇到，但不太懂的小知识点</p><h2 id="一、回调函数概念"><a href="#一、回调函数概念" class="headerlink" title="一、回调函数概念"></a>一、回调函数概念</h2><p>参考：</p><ul><li><a href="https://dmitripavlutin.com/javascript-callback/">Everything About Callback Functions in JavaScript</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017328655674400">高阶函数-廖雪峰</a><br>其他网站关于回调函数概念的描述很详细，我就不再赘述了，这里主要记录一下，这两个参考网站给我的启发<br>廖雪峰在关于pytjon的高阶函数一文中说到：<blockquote><p>函数本身也可以赋值给变量，即：变量可以指向函数<br>函数名其实就是指向函数的变量<br>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数 </p></blockquote></li></ul><p>回到js中，这个高阶函数其实也就是我们说的以回调函数作为其参数之一的的高阶函数</p><blockquote><p>The callback function is supplied as an argument to a higher-order function that invokes (“calls back”) the callback function to perform an operation.  </p></blockquote><p>也就是说：回调函数就是作为一个实参传递给高阶函数，接下来高阶函数完全负责调用回调并为其提供正确的参数</p><h3 id="1-使用方法："><a href="#1-使用方法：" class="headerlink" title="1. 使用方法："></a>1. 使用方法：</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="function"><span class="title">higherOrder</span>(<span class="params">param, callback</span>)</span> {</span><br><span class="line">    <span class="keyword">let</span> a = param + <span class="number">2</span></span><br><span class="line">    callback(a)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="title">printdata</span>(<span class="params">data</span>)</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法: 普通参数正常传值，回调函数就传入函数名即可</span></span><br><span class="line">higherOrder(<span class="number">3</span>, printData)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h2 id="二、遇到的问题"><a href="#二、遇到的问题" class="headerlink" title="二、遇到的问题"></a>二、遇到的问题</h2><h3 id="如何从外部获取回调函数的返回值？"><a href="#如何从外部获取回调函数的返回值？" class="headerlink" title="如何从外部获取回调函数的返回值？"></a>如何从外部获取回调函数的返回值？</h3><p>在写项目的过程中我陷入了这样的一个问题中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在公用js文件中定义的函数，通过一个外部服务的接口可以获得data</span></span><br><span class="line"><span class="function"><span class="title">getFile</span>(<span class="params">a</span>)</span> {</span><br><span class="line">    client.getObj(a, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{</span><br><span class="line">        ....</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用的vue组件中，我需要把data传递到这个组件中并用来赋值或渲染数据到页面中</span></span><br><span class="line"><span class="function"><span class="title">useData</span>(<span class="params">data</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.name = data.name</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>最开始我的做法是，在getFile中return data，但发现useData中根本获取不到返回值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在公用js文件中定义的函数，通过一个外部服务的接口可以获得data</span></span><br><span class="line"><span class="function"><span class="title">getFile</span>(<span class="params">a</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> client.getObj(a, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用的vue组件中，我需要把data传递到这个组件中并用来赋值或渲染数据到页面中</span></span><br><span class="line"><span class="function"><span class="title">useData</span>(<span class="params">data</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.name = data.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体用法</span></span><br><span class="line"><span class="keyword">let</span> data = getFile(a) <span class="comment">// 这里打印出来发现是undefined</span></span><br><span class="line">useData(data)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>后来查了很多资料发现，我们不能在外部获取回调函数的返回值，但我们可以把想要对回调函数中数据做的操作当成一个回调函数传递进去<br>解决方法如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在公用js文件中定义的函数，通过一个外部服务的接口可以获得data</span></span><br><span class="line"><span class="function"><span class="title">getFile</span>(<span class="params">a, callback</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> client.getObj(a, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用的vue组件中，我需要把data传递到这个组件中并用来赋值或渲染数据到页面中</span></span><br><span class="line"><span class="function"><span class="title">useData</span>(<span class="params">data</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.name = data.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体用法</span></span><br><span class="line">getFile(a, useData)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录我在开发过程中总遇到，但不太懂的小知识点&lt;/p&gt;
&lt;h2 id=&quot;一、回调函数概念&quot;&gt;&lt;a href=&quot;#一、回调函数概念&quot; class=&quot;headerlink&quot; title=&quot;一、回调函数概念&quot;&gt;&lt;/a&gt;一、回调函数概念&lt;/h2&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>一些前端小知识点</title>
    <link href="http://example.com/2022/07/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9%EF%BC%8C%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/07/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9%EF%BC%8C%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-07-10T11:20:23.261Z</published>
    <updated>2023-03-06T06:42:10.488Z</updated>
    
    <content type="html"><![CDATA[<p>记录我在开发过程中总遇到，但不太懂的小知识点</p><h2 id="一、常见英语单词"><a href="#一、常见英语单词" class="headerlink" title="一、常见英语单词"></a>一、常见英语单词</h2><ul><li>instance 实例</li><li>context 语境，上下文</li><li>property 属性</li><li>Actual Argument 实际参数</li><li>Formal Parameter 形式参数（Argument 和 Parameter 两个词在很多文献中均翻译为参数）</li><li>higher-order function <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017328655674400">高阶函数：函数名本身就是一个指向函数的变量</a> </li><li>invoke 调用</li><li>align 对齐</li><li>assembly 部件</li><li>plugin 插件</li><li>annotation 注解，注释，批注（多行，针对方法，程序，可以添加一些参数@name..）</li><li>comment 评论，单行注释</li><li>amulate 模仿</li><li>portal 入口，门户，一个基于web的应用程序。它主要提供个性化、单点登录、不同来源的内容整合以及存放信息系统的表示层</li><li>configuration 配置</li><li>deprecated 已弃用</li></ul><h2 id="二、vue相关"><a href="#二、vue相关" class="headerlink" title="二、vue相关"></a>二、vue相关</h2><ol><li>vue.use()是vue使用插件的固定语句</li><li>vue中<code>data</code>是会返回一个对象的函数，<code>methods</code> 选项是一个包含所有方法的对象,其他生命周期钩子也都是会被调用的函数<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span><br><span class="line">   <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">data1</span>:<span class="string">''</span>,</span><br><span class="line">      <span class="attr">data2</span>:<span class="string">''</span></span><br><span class="line">   }</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: {</span><br><span class="line">   <span class="function"><span class="title">function1</span>(<span class="params"></span>)</span> {</span><br><span class="line">      ...</span><br><span class="line">   },</span><br><span class="line">   <span class="function"><span class="title">function2</span>(<span class="params"></span>)</span> {</span><br><span class="line"></span><br><span class="line">   },</span><br><span class="line">   ...</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="三、css相关"><a href="#三、css相关" class="headerlink" title="三、css相关"></a>三、css相关</h2><ol><li>bootstrap中常用的一些class<ul><li>fs-1 ~ fs-7 字号从大到小</li><li>fw-bold 字体加粗</li><li>mt、mb、ms、me分别控制上下左右的margin</li><li>rounded 控制边框弧度</li><li>gap-2 控制子组件的间隔</li><li>bg-white控制背景颜色</li><li>align-middle 定义在子标签上，让子标签纵向居中（在css中middle是说纵向居中，center是横向）</li></ul></li></ol><h2 id="四、js相关"><a href="#四、js相关" class="headerlink" title="四、js相关"></a>四、js相关</h2><h4 id="1-没有异常回调函数的时候可以用try-catch"><a href="#1-没有异常回调函数的时候可以用try-catch" class="headerlink" title="1. 没有异常回调函数的时候可以用try-catch"></a>1. 没有异常回调函数的时候可以用try-catch</h4><h4 id="2-分号问题"><a href="#2-分号问题" class="headerlink" title="2. 分号问题"></a>2. 分号问题</h4><ul><li>一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。</li><li>加与不加完全取决于个人意愿，不会影响程序的运行。</li><li>分号的添加是可选的，“可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy…</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录我在开发过程中总遇到，但不太懂的小知识点&lt;/p&gt;
&lt;h2 id=&quot;一、常见英语单词&quot;&gt;&lt;a href=&quot;#一、常见英语单词&quot; class=&quot;headerlink&quot; title=&quot;一、常见英语单词&quot;&gt;&lt;/a&gt;一、常见英语单词&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;instance 实</summary>
      
    
    
    
    <category term="前端基础" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-i18n插件用法</title>
    <link href="http://example.com/2022/07/10/Vue%E6%8F%92%E4%BB%B6/vue-i18n%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/07/10/Vue%E6%8F%92%E4%BB%B6/vue-i18n%E7%94%A8%E6%B3%95/</id>
    <published>2022-07-10T08:06:21.329Z</published>
    <updated>2023-03-06T06:32:10.124Z</updated>
    
    <content type="html"><![CDATA[<p>vue-i18n是一个vue插件，可以让vue项目实现多语言，国际化。参考：</p><ul><li><a href="https://kazupon.github.io/vue-i18n/started.html">vue-i18n官方文档</a></li><li><a href="https://segmentfault.com/a/1190000015008808">segmentfault: 如何让一个vue项目支持多语言</a><h2 id="一、引入vue-i18n插件"><a href="#一、引入vue-i18n插件" class="headerlink" title="一、引入vue-i18n插件"></a>一、引入vue-i18n插件</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过全局方法使用插件</span></span><br><span class="line">Vue.use(VueI18n)</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="二、vue-i18n的最简单的使用模板"><a href="#二、vue-i18n的最简单的使用模板" class="headerlink" title="二、vue-i18n的最简单的使用模板"></a>二、vue-i18n的最简单的使用模板</h2><p>分为以下4个部分：</p><ul><li>message字典对象</li><li>创建vue-i18n实例</li><li>创建vue实例时将i18n作为option传递进去</li><li>在vue组件中使用i18n<ul><li>在组件的template中，调用$t()方法</li><li>在组件的script中，调用this.$i18n.t()方法<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** JAVASCRIPT</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含多语言的对象字典</span></span><br><span class="line"><span class="keyword">const</span> messages = {</span><br><span class="line"><span class="attr">en</span>: {</span><br><span class="line">    <span class="attr">message</span>: {</span><br><span class="line">    <span class="attr">hello</span>: <span class="string">'hello world'</span></span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line"><span class="attr">ja</span>: {</span><br><span class="line">    <span class="attr">message</span>: {</span><br><span class="line">    <span class="attr">hello</span>: <span class="string">'こんにちは、世界'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 VueI18n 实例 with options</span></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n({</span><br><span class="line"><span class="attr">locale</span>: <span class="string">'ja'</span>, <span class="comment">// set locale 默认使用日语</span></span><br><span class="line">messages, <span class="comment">// set locale messages 多语言字典</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实例化vue时，将i18n当作一个option传进去，之后就可以在vue组件中使用i18n了</span></span><br><span class="line"><span class="keyword">new</span> Vue({ i18n }).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** HTML</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 在组件中使用i18n插件</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>{{ $t("message.hello") }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为日语</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>こんにちは、世界<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="三、在项目中使用i18n"><a href="#三、在项目中使用i18n" class="headerlink" title="三、在项目中使用i18n"></a>三、在项目中使用i18n</h2><p>  上节的messages是一个包含了多语言的的对象，它就像我们的字典。既然是字典，我希望它只有一本。所以我只会new VueI18n()一次，并将实例化得到的i18n对象作为唯一的字典。<br>  新建一个locales文件夹，存放所有跟多语言相关的代码。目前包含三个文件：</p><ul><li>index.js : 统一设置locales文件夹下的语言包</li><li>en.json : 【英语】json形式的语言包，为了对照方便，我们必须保证语言包的内容是一一对应的</li><li>zh.json : 【中文】</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_LANG = <span class="string">'zh'</span></span><br><span class="line"><span class="keyword">const</span> LOCALE_KEY = <span class="string">'localeLanguage'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置多语言字典对象</span></span><br><span class="line"><span class="keyword">const</span> locales = {</span><br><span class="line">  <span class="attr">zh</span>: <span class="built_in">require</span>(<span class="string">'./zh.json'</span>),</span><br><span class="line">  <span class="attr">en</span>: <span class="built_in">require</span>(<span class="string">'./en.json'</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建i18n实例对象（配置默认语言和字典对象）</span></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n({</span><br><span class="line">  <span class="attr">locale</span>: DEFAULT_LANG,</span><br><span class="line">  <span class="attr">messages</span>: locales,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup方法可以用来切换语种</span></span><br><span class="line"><span class="comment">// 将当前语种存到 localStorage中，保存用户的使用习惯</span></span><br><span class="line"><span class="comment">// 给body添加语种相关的class，因为不同语言可能导致排版出现差异，我们需要适配</span></span><br><span class="line"><span class="comment">// 将当前语种存到Vue的全局配置中，以便未来可能的使用。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setup = <span class="function"><span class="params">lang</span> =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (lang === <span class="literal">undefined</span>) {</span><br><span class="line">    lang = <span class="built_in">window</span>.localStorage.getItem(LOCALE_KEY)</span><br><span class="line">    <span class="keyword">if</span> (locales[lang] === <span class="literal">undefined</span>) {</span><br><span class="line">      lang = DEFAULT_LANG</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(LOCALE_KEY, lang)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(locales).forEach(<span class="function"><span class="params">lang</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">document</span>.body.classList.remove(<span class="string">`lang-<span class="subst">${lang}</span>`</span>)</span><br><span class="line">  })</span><br><span class="line">  <span class="built_in">document</span>.body.classList.add(<span class="string">`lang-<span class="subst">${lang}</span>`</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.setAttribute(<span class="string">'lang'</span>, lang)</span><br><span class="line"></span><br><span class="line">  Vue.config.lang = lang</span><br><span class="line">  i18n.locale = lang</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>最后在main.js中引入这个index.js即可</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'@crm/locales'</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  i18n,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">}).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="四、-可能遇到的问题"><a href="#四、-可能遇到的问题" class="headerlink" title="四、 可能遇到的问题"></a>四、 可能遇到的问题</h2><h3 id="1-问题一：vue实例外的js代码中的文本怎么替换？"><a href="#1-问题一：vue实例外的js代码中的文本怎么替换？" class="headerlink" title="1. 问题一：vue实例外的js代码中的文本怎么替换？"></a>1. 问题一：vue实例外的js代码中的文本怎么替换？</h3><p>前面说到，vue实例中我们可以使用this.$i18n.t，这里的this是vue的实例。那项目中很多js代码在vue的实例之外，我们要怎么办？</p><p>最简单的解决方法是这样的，我们的locales/index.js这个文件已经export了i18n这个对象，那我们只需要在每次要使用的时候手动将i18n导入进来就可以了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'@crm/locales'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const test = "测试数据"</span></span><br><span class="line"><span class="keyword">const</span> test = i18n.t(<span class="string">'message.test'</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>可是这样一来，我们之后做诸如上面的文本替换时，就得小心翼翼的区别是否在vue实例中。如果是，我们用this.$i18n.t，否则先import然后用i18n.t。这显然增加了复杂性！</p><p>为了解决这个问题，只直接的解决办法就是将i18n挂到window下，变成全局变量。我们就不必再Import进来，同时只使用统一方法:i18n.t。</p><p>我们在main.js中添加这行代码:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./app.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'@crm/locales'</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.i18n = i18n</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  i18n,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">}).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><p>然后我们兴高采烈的将组件中的import i18n全去掉，并将this.$i18n.t改为i18n.t。然后项目跑起来就报错了：i18n is not defined。</p><p>问题出在哪里？显示是组件调用i18n的时候，i18n还没有挂载到window上，所以是执行顺序出了问题。我们先来看一下下面代码的执行顺序：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设webpack的入口文件是```main.js```</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">'moduleA'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> moduleB <span class="keyword">from</span> <span class="string">'moduleB'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleA.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终在浏览器中打印出的数字顺序是: </span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>为什么会这样呢？跟ES6 module的机制有关系。import命令具有提升效果，会提升到整个模块的头部，首先执行。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。</p><p>这样我们就找出之前报错的原因了，我们先import了App, router这些视图，然后Import的i18n并挂载到window。所以组件的script中的代码会最先执行，而此时i18n并未开始。所以我们首先将window.i18n = i18n移到locales/index中，然后调整main.js中import的顺序:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//locales/index</span></span><br><span class="line">...</span><br><span class="line">setup()</span><br><span class="line"><span class="built_in">window</span>.i18n = i18n</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'@crm/locales'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./app.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="2-假如存在很多个new-Vue-怎么办？"><a href="#2-假如存在很多个new-Vue-怎么办？" class="headerlink" title="2. 假如存在很多个new Vue()怎么办？"></a>2. 假如存在很多个new Vue()怎么办？</h3><p>前面我们在main.js的new Vue({i18n, …})中将i18n作为option放了进去，但很快我发现这个项目并只有一个Vue的实例。全局搜索发现一共有70多个。</p><p>项目中很的诸如弹窗之类的组件，都是直接自己实例化一个Vue然后自己$mount()到DOM中。这些组件在实例化的过程中并没有混入i18n选项，所以他们的template上自然找不到$t()方法。</p><p>怎么办？难道给每一个new Vue()都手动添加i18n选项吗？肯定不行，首先我们要给添加70多次，其次如果未来又有人写了新的new Vue()忘了添加Ii8n，那又回导致报错。所以我们要想一个万全的法子。</p><p>官方文档里找不到解决办法，看来我们得hack一下了。首先我们来查vue-i18n的源码，找到$t()方法是怎么工作的。</p><p>全局搜索$t，找到定义它的地方：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$t'</span>, {</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> this$<span class="number">1</span> = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>{</span><br><span class="line">      <span class="keyword">var</span> values = [], len = <span class="built_in">arguments</span>.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> ( len-- &gt; <span class="number">0</span> ) values[ len ] = <span class="built_in">arguments</span>[ len + <span class="number">1</span> ];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> i18n = this$<span class="number">1.</span>$i18n;</span><br><span class="line">      <span class="keyword">return</span> i18n._t.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this$<span class="number">1</span> ].concat( values ))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>可以看到$t挂载在Vue.prototype上，每当我们在实例中调用$t时，其实我们是在调用this.$i18n对象上的_t方法。现在问题变成，实例上的$i18n是什么是时候定义的。</p><p>全局搜索$i18n，我们找到了前面提到过的每个插件必须提供的install方法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>) </span>{</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$i18n'</span>, {</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="built_in">this</span>._i18n }</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  extend(Vue);</span><br><span class="line">  Vue.mixin(mixin);</span><br><span class="line">  Vue.directive(<span class="string">'t'</span>, { <span class="attr">bind</span>: bind, <span class="attr">update</span>: update });</span><br><span class="line">  Vue.component(component.name, component);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use object-based merge strategy</span></span><br><span class="line">  <span class="keyword">var</span> strats = Vue.config.optionMergeStrategies;</span><br><span class="line">  strats.i18n = strats.methods;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到$i18n一开始就被定义在了Vue.prototype上，每次调用的时候其实我们是在调用this._i18n，所以现在问题变成实例的_i18n在哪里。同时可以看到在Install中我们还混入了mixin, directive, component，这些在上面都有提过它的作用。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = {</span><br><span class="line">  <span class="attr">beforeCreate</span>: <span class="function"><span class="keyword">function</span> <span class="title">beforeCreate</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> options = <span class="built_in">this</span>.$options;</span><br><span class="line">    options.i18n = options.i18n || (options.__i18n ? {} : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.i18n) {</span><br><span class="line">      <span class="keyword">if</span> (options.i18n <span class="keyword">instanceof</span> VueI18n) {</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">this</span>._i18n = options.i18n;</span><br></pre></td></tr></tbody></table></figure><p>我们在mixin中找到了this._i18n的来源，前面提到mixin会被注入到组件中。在每个组件创建前，我们将this.$options的i18n给了this._i18n。</p><p>这个this.$options是什么？它的使用方式是Vue.mixin(mixin)，所以我们看一下vue的文档:全局混入</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></span><br><span class="line">Vue.mixin({</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="built_in">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) {</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  <span class="attr">myOption</span>: <span class="string">'hello!'</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">// =&gt; "hello!"</span></span><br></pre></td></tr></tbody></table></figure><p>所以this.$options就是我们new Vue时提供的选项对象。</p><p>所以问题的根源就是除了main.js中的new Vue外，其余70多个new Vue我们没有混入i18n这个选项。怎样才可以让每次new Vue时自动将i18n混入选项呢？看上去我们只能修改Vue的源码了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) {</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到每次Vue实例化时，会调用_init方法，这个方法从哪里来呢？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue</span>) </span>{</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>{</span><br><span class="line">    ...</span><br><span class="line">在Vue.prototype上，所以我们只需要修改Vue.prototype就好了。</span><br><span class="line"></span><br><span class="line"><span class="comment">//locales/index</span></span><br><span class="line"><span class="keyword">const</span> init = Vue.prototype._init</span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>{</span><br><span class="line">  init.call(<span class="built_in">this</span>, {</span><br><span class="line">    i18n,</span><br><span class="line">    ...options,</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们在任何时候new Vue()就自动添加了i18n选项，问题解决！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vue-i18n是一个vue插件，可以让vue项目实现多语言，国际化。参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kazupon.github.io/vue-i18n/started.html&quot;&gt;vue-i18n官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Vue插件" scheme="http://example.com/categories/Vue%E6%8F%92%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>vue生命周期的概念及用法</title>
    <link href="http://example.com/2022/07/04/Vue%E7%94%9F%E6%80%81/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/07/04/Vue%E7%94%9F%E6%80%81/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-07-04T14:23:13.580Z</published>
    <updated>2023-03-06T06:33:00.523Z</updated>
    
    <content type="html"><![CDATA[<p>vue的生命周期在做项目的过程中经常需要用到，在这里做简要记录,参考:</p><ul><li><a href="https://juejin.cn/post/6874855535234170887">vue生命周期详解</a></li><li><a href="https://bbs.huaweicloud.com/blogs/278913">一文带你弄懂Vue八大生命周期钩子函数</a></li><li><a href="https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html">生命周期钩子</a></li></ul><h2 id="一、vue生命周期概述"><a href="#一、vue生命周期概述" class="headerlink" title="一、vue生命周期概述"></a>一、vue生命周期概述</h2><ul><li>我们把一个对象从生成（new）到被销毁（destory）的过程，称为生命周期。</li><li>vue的生命周期就是每个Vue实例在被创建时都要经过一系列的初始化过程：创建实例，装载模板，渲染模板等。Vue为生命周期中的每个状态都设置了钩子函数(监听函数) 。</li><li>每当Vue实例处于不同的生命周期时，对应的钩子函数就会被触发调用。我们可以根据自己的需要在这些钩子函数中加入自己的代码。</li></ul><h2 id="二、四个阶段，八个生命周期函数"><a href="#二、四个阶段，八个生命周期函数" class="headerlink" title="二、四个阶段，八个生命周期函数"></a>二、四个阶段，八个生命周期函数</h2><h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><p>这个阶段 vue组件开始初始化，vue开始观察数据，这个阶段有 beforeCreate 和 created 两个生命周期钩子函数。<br><strong>1.1 beforeCreate阶段</strong><br>在实例初始化（即new Vue()）之后、进行数据侦听和事件/侦听器的配置之前同步调用。此时 data、methods、computed以及watch上的数据和方法还未初始化，都不能被访问。<br>应用：我们可以在这个周期去初始化store，将localstorage中的数据复制到store中，参考<a href="https://www.mikestreety.co.uk/blog/vue-js-using-localstorage-with-the-vuex-store/">Vue: Using localStorage with Vuex store</a><br><strong>1.2 created</strong><br>在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。<br>可以做什么：</p><ul><li>data 和 methods 都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作。</li><li>无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</li><li>异步数据的请求适合在 created 的钩子中使用，例如数据初始化。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 这里created中getElementById会出错，因为视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素</span><br><span class="line">// 而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点。</span><br><span class="line">created:function(){</span><br><span class="line">  this.name="唐浩益"</span><br><span class="line">  this.age = "12"</span><br><span class="line">  this.city ="杭州"</span><br><span class="line">  var x = document.getElementById("name")//第一个命令台错误</span><br><span class="line">  console.log(x.innerHTML);</span><br><span class="line">},</span><br><span class="line">mounted:function(){</span><br><span class="line">  var x = document.getElementById("name")//第二个命令台输出的结果</span><br><span class="line">  console.log(x.innerHTML);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-挂载阶段"><a href="#2-挂载阶段" class="headerlink" title="2. 挂载阶段"></a>2. 挂载阶段</h3></li></ul><p><strong>2.1 beforeMount</strong><br>这个阶段完成了模板的编译，但是还没挂载到页面上。<br>要挂载的dom对象编译好了，但是页面的DOM树还没挂上去，这个阶段页面还没能显示出来。<br><strong>2.2 mounted</strong><br>这个阶段，模板编译好了，也挂载到页面中了，页面也可以显示了。<br>这里就可以使用document.getElementById去操作挂载好的dom元素了</p><blockquote><p>在实例挂载完成后被调用，这时候传递给 app.mount 的元素已经被新创建的 vm.$el 替换了。如果根实例被挂载到了一个文档内的元素上，当 mounted 被调用时， vm.$el 也会在文档内。 注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted() {</span><br><span class="line">  this.$nextTick(function () {</span><br><span class="line">    // 仅在整个视图都被渲染之后才会运行的代码</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该钩子在服务器端渲染期间不被调用。</p><h3 id="3-运行阶段"><a href="#3-运行阶段" class="headerlink" title="3. 运行阶段"></a>3. 运行阶段</h3><p><strong>3.1 beforeUpdate</strong></p><ul><li>data中的数据已经更改</li><li>准备挂载的dom中的数据也已更改</li><li>页面已挂载的dom还未更改<blockquote><p>在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。<br>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</p></blockquote></li></ul><p><strong>3.2 updated</strong></p><ul><li>页面已挂载的dom也更新了</li><li>我们应该避免在这个钩子函数中去更改状态，因为刚更改结束<blockquote><p>updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等待整个视图都渲染完毕，可以在 updated 内部使用 vm.$nextTick：</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// 仅在整个视图都被重新渲染完毕之后才会运行的代码</span></span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>用法，目前我自己还没有用到，百度发现了一个博主在做的即时聊天项目，打开当前会话加载完消息后需要自动滚动到窗口最底部，这里用updated就很合适<br>参考<a href="https://blog.csdn.net/weixin_44041976/article/details/107584572">vue updated生命周期的使用场景，可以做什么</a><h3 id="4-销毁阶段"><a href="#4-销毁阶段" class="headerlink" title="4. 销毁阶段"></a>4. 销毁阶段</h3></li></ul><p><strong>4.1 beforeDestroy(vue3中定义为beforeUnmount)</strong></p><ul><li>beforeDestroy阶段处于vue实例被销毁之前，当然，这个阶段vue实例还能用.我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>该钩子在服务器端渲染期间不被调用。</li></ul><p><strong>4.2 destroyed(vue3:unmounted)</strong></p><ul><li>卸载组件实例后调用。调用此钩子时，只剩下了dom空壳,组件已被拆解，数据绑定被卸除,组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</li><li>该钩子在服务器端渲染期间不被调用<blockquote><p>在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。</p></blockquote><h2 id="三、生命周期示意图"><a href="#三、生命周期示意图" class="headerlink" title="三、生命周期示意图"></a>三、生命周期示意图</h2><img src="https://cn.vuejs.org/images/lifecycle.png" alt="生命周期示意图"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vue的生命周期在做项目的过程中经常需要用到，在这里做简要记录,参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6874855535234170887&quot;&gt;vue生命周期详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue首次赋值不触发watch</title>
    <link href="http://example.com/2022/06/08/Vue%E7%94%9F%E6%80%81/vue%20watch%E9%A6%96%E6%AC%A1%E8%B5%8B%E5%80%BC%E5%B0%B1%E8%A7%A6%E5%8F%91/"/>
    <id>http://example.com/2022/06/08/Vue%E7%94%9F%E6%80%81/vue%20watch%E9%A6%96%E6%AC%A1%E8%B5%8B%E5%80%BC%E5%B0%B1%E8%A7%A6%E5%8F%91/</id>
    <published>2022-06-08T06:54:22.800Z</published>
    <updated>2023-03-06T06:32:52.928Z</updated>
    
    <content type="html"><![CDATA[<p>通过watch监听的数据，当字段被第一次赋值时是不会执行监听函数的。只有值再次发生改变才会执行监听。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>参考：<a href="https://blog.csdn.net/Liu_yunzhao/article/details/95395427">vue首次赋值不触发watch及watch和computed的区别</a><br>在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调<br>也就是说immediate值为true，则首次赋值时就执行handler函数，immediate值为false，则首次赋值时就不执行handler函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line">    <span class="attr">name</span>: {</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> {},</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">age</span>: {</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> {},</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过watch监听的数据，当字段被第一次赋值时是不会执行监听函数的。只有值再次发生改变才会执行监听。&lt;/p&gt;
&lt;h3 id=&quot;解决方法：&quot;&gt;&lt;a href=&quot;#解决方法：&quot; class=&quot;headerlink&quot; title=&quot;解决方法：&quot;&gt;&lt;/a&gt;解决方法：&lt;/h3&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
  </entry>
  
</feed>
